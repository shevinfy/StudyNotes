# 一、前导

定义上**深度优先搜索的思路与树的先序遍历非常相似**，是==**针对图的搜索**==而提出的一种算法，下面时算法导论上的解散：

> 在深度优先搜索中，对于最新发现的顶点，如果它还有以此为顶点而未探测到的边，就沿此边继续探测下去，当顶点v的所有边都已被探寻过后，搜索将回溯到发现顶点v有起始点的那些边。这一过程一直进行到已发现**从源顶点可达的所有顶点为止**。如果还存在未被发现的顶点，则选择其中一个作为源顶点，并重复上述过程。整个过程反复进行，直到所有的顶点都被发现时为止。

> 在深度优先搜索中，每当扫描到已发现的顶点u的邻接表，从而发现新顶点v时，就将置v的先辈域Π[v]为u。与广度优先搜索不同的是，其先辈子图形成一棵树，深度优先搜索产生的先辈子图可以有几棵树所构成，因为搜索可能由多个源顶点开始重复进行。因此，在深度优先搜索中，先辈子图的定义也和广度优先搜索中稍有所不同：GΠ = (V, EΠ)，其中EΠ = {(Π[v], v) : v ∈V 且 Π[v] ≠ NIL}

## 深度优先搜索问题进行**分类**：

1.定义的DFS：对图的连通性进行测试，典型问题：迷宫连通性测试，图的条件搜索等。

2.广义的DFS-DFS思路的应用：DFS搜索顺序+规则问题、穷举结果需求最优解、符合条件解等等，由于穷尽答案的本质，又被称为爆搜。



**深度优先搜索**(统称DFS)的精髓在于==递归求解问题的思路以及回溯的处理==。而针对搜索的过程，又有更为重要的**剪枝、优化**，必要的剪枝优化(通过对穷举答案方式进行改进)对DFS的顺利执行有着不可或缺的作用。

# 二、原理分类与分析

## 1. DFS连通性模型

> 在测试图的连通性时，DFS与实际人们的思想一致，相对于起点选择一条路走到底，发现不行就返回选择的节点换一条路试，直到试出一条能到达终点的路。当然，一直试不出来就表示该起点与某点(终点)不连通。其他DFS连通性模型的思想与之类似。

针对实际问题，我又将连通性模型按照是否需要回溯继续细分：

### 1.无需回溯：统计某点能到达的点的个数问题

在这类问题中，我们一般从某点出发进行搜索，对于已经被搜索过的点可以直接抛弃(标记不可访问)，对于当前被搜索的点递归搜索周围邻接的点并进行计数，直到无法搜索到合法的点返回。最终计数变量将记录所有能到达的点。

> 典型模板题：ACWing.1113 红与黑
>
> 解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109243556X

### 2.需要回溯：迷宫类问题，测试两点间连通性

在这类问题中，由于当前选择的路径未必能够到达目标点，因此需要设置回溯，当搜索到非法路径返回时需要“恢复现场”，即：对于该路径下各点的访问状态重置。具体的搜索过程如下图所演示：

![在这里插入图片描述](DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.assets/20201110173058707.gif)

> 典型模板题：ACWing.1112 迷宫
>
> 解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109239579
>
> 二维矩阵里走迷宫，非常简单

> 典型模板题：ACWing.1116 马走日
>
> 解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109247649
>
> 这题堪称经典，与迷宫模板不同的是移动路径的选择和点合法性的判断，属于简单的搜索题



# 总结一下DFS的模板框架(简单描述)

```
function dfs(当前状态){
	if(当前状态 == 目的状态){
        ···
    }
    for(···寻找新状态){
        if(状态合法){
            vis[访问该点]；
            dfs(新状态);
            ?是否需要恢复现场->vis[恢复访问]
        } 
    }
    if(找不到新状态){
        ···
    }
}
```

# 三、剪枝优化、题型归纳总结(未完待续)

> 在通过搜索解决实际问题的过程中，我们是通过穷举每种情况来寻找合法解，然而在一些情况比较复杂的题目、数据量较强的题目中，由于算法的时间**复杂度较高、数据规模过大**，从而会导致运行超时甚至程序卡死，因此在对复杂问题的答案进行搜索时，我们应该灵活的针对每种题型设计对应的搜索规则并进行==优化==，通常通过==设置剪枝、排除无效情况==、对问题进行适当的转化等手法对搜索算法进行优化，使算法高效的执行并得出我们想要的结果。
>
> 对**算法的剪枝与优化堪称是爆搜算法的精髓**，如何合理的设置剪枝优化直接关系能否得到结果，这对我们的解题思维是一个很大的挑战，本板块将对常见的剪枝优化思路、对细节的处理进行归纳总结。

### 概述：剪枝与优化

#### ①.剪枝与优化的原则

> **1.正确性**
>
> 剪枝优化的过程是使算法逼近最优解的过程，而不是使算法远离最优解甚至跳过最优解的过程。剪枝的前提是**保证对最优解不丢不漏**。

> **2.准确性**
>
> 在保证正确性的前提下，我们采取必要的手段使算法**跳过一定不含有目标状态/最优解的分支**，从而保证算法高效地进行并更迅速的找出

> **3.高效性**
>
> 设计优化程序的根本目的,是要减少搜索的次数,使程序运行的时间减少. 但为了使搜索次数尽可能的减少,我们又必须花工夫设计出一个准确性较高的优化算法,而当算法的准确性升高,其判断的次数必定增多,从而又导致耗时的增多,这便引出了矛盾. 因此,如何在优化与效率之间寻找一个平衡点,使得程序的时间复杂度尽可能降低,同样是非常重要的。

#### ②剪枝与优化的一般入手点

> 1.优化搜索顺序：
>
> 在一些题目中，可以通过对子问题分支进行分析，先解决相对简单的子问题从而使尚未解决的子问题得到简化，通过对搜索顺序的优化可以实现这一点。

> 2.排除冗余信息：
>
> 对限制条件进行分析，不要额外添加没有意义的搜索规则

> 3.可行性剪枝：
>
> 对于显然不包含目标状态的搜索方向及时停止搜索，转而向可能包含目标状态的分支进行搜索

> 4.最优性剪枝：
>
> 每次搜索完成后更新当前得到的最优状态/最优解，在每次搜索开始前判断当前解是否已经比上次得出的状态/解更劣？如果是则停止本次搜索，转向其他搜索分支

# 参考文章：

[(36条消息) 深度优先搜索(DFS) 总结(算法+剪枝+优化总结)_HeartFireY的博客-CSDN博客](https://blog.csdn.net/yanweiqi1754989931/article/details/109603384)