shevin°:
八股文：https://docs.qq.com/doc/p/5caa3cf233146cd625e57cd9938eedf99e5e8dcd

##             1.     **面向过程与面向对象的区别**

面向过程：面向过程的**程序性能**比面向对象高，因为**类实例化时需要消耗资源**，所以面向对象开销更大。

面向对象：面向对象的程序更加容易**维护，复用和扩展**。因为面向对象具有**封装，继承和多态**等特性，所以可以设计出**低耦合**的系统，使系统更加灵活，容易维护。

当性能是最重要的因素时，如单片机，嵌入式，Linux系统一般采用面向过程开发。当开发大型软件系统时，一般采用面向对象开发，更加易于维护。

##             2.     **Java语言的特点**

1.面向对象（拥有**继承，封装和多态**三大特性）

2.平台无关性（编译后形成字节码文件由JVM执行，**支持跨平台**）

3.编译（ 将源代码==**一次性**==转换成目标代码的过程  ）与解释( 将源代码逐条转换成目标代码同时逐条运行的过程。  )并存（Java程序首先由编译器进行编译，形成的中间代码由JVM解释执行）

4.可靠安全（有异常处理机制和垃圾回收机制，去除指针特性）

5.提供了很多**内置类库**（如对多线程的支持，对网络通信的支持）

6.提供了对web应用程序的开发支持。

##             3.     **什么是JVM？**

JVM是**运行Java字节码的虚拟机**。JVM有针对不同系统的特定实现，目的是使用**相同**的字节码，JVM运行都会给出**相同的结果。**

##             4.     **什么是字节码？采用字节码有什么好处？**

**JVM可以理解运行的代码**叫做字节码，也就是扩展名为.class的文件。Java通过字节码方式，在一定程度上解决了传统解释型语言**执行效率低**的问题，同时又保留了解释型语言**可移植**的特点。

##             5.     **Java从源代码到运行的三步是什么？**

首先java源代码被JDK中的javac编译形成.class文件，然后由JVM解释执行，形成机器可以执行的**二进制机器码**，最后在硬件机器上执行二进制机器码。

其中在**形成二进制机器代码时**，因为直接**逐行解释执行效率较低**，所以引入了**JIT**(Just-in-time，即时编译，边运行边编译)编译器**保留热点代码**，提高**经常运行**的代码的效率。JDK9引入了一种新的**编译模式AOT(**Ahead of Time Compilation)提前编译”.**直接将字节码编译成机器码**，避免了JIT预热方面的开销，但**编译质量**不如JIT编译器（优化）。

## 6. **静态编译与动态编译的区别：**

动态编译的可执行文件需要**附带一个**的动态链接库，在执行时，需要调用其**对应动态链接库中的命令**。

所以其**优点**一方面是**缩小了执行文件本身的体积**，另一方面是**加快了编译速度**，节省了系统资源。

**缺点**一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也**需要附带一个相对庞大的链接库**；二是**如果其他计算机上没有安装对应的运行库**，则**用动态编译的可执行文件就不能运行**。

静态编译 就是程序在**执行前**全部被翻译为机器码，编译器在编译可执行文件的时候，将可执行文件需要调用的对应动态链接库(.so)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候**不依赖于动态链接库**。所以其优缺点与动态编译的可执行文件正好互补。  

```
Java的动态链接库是一种库文件，其中包含了Java代码和本地机器代码的二进制形式，可以在Java程序中动态地加载和链接。这些库文件通常具有扩展名为“.dll”（在Windows平台上）或“.so”（在Unix / Linux平台上）。

在Java中，可以使用Java本机接口（JNI）来访问动态链接库中的本地机器代码。通过JNI，Java程序可以调用动态链接库中的函数，传递参数并获得返回值。
```



## 7. **JRE与JDK分别是什么？**

JRE是Java运行时环境，包括JVM,Java类库，Java命令和其他的一些基础构件。不能用于创建新程序。

JDK是Java开发环境，除了拥有JRE拥有的一切还有编译器(javac)和工具（如javadoc和jdb）。能够创建和编译程序。



## 8. **Open JDK与Orcle JDK有什么区别?**

Open jdk项目主要基于Sun公司捐赠的HotSpot源代码，是一个参考模型并且是完全开源的，Orcle jdk是Open jdk的一个实现，面向商用，并不是完全开源的。Orcle jdk比Open jdk提供了更好的响应性和性能。

```
性能差异可以归因于Oracle JDK和OpenJDK的不同实现方式。Oracle JDK的实现中包含了一些专有的代码和优化，例如垃圾回收器（Garbage Collector）和即时编译器（Just-In-Time Compiler），这些代码和优化能够提高Java程序的性能和响应性。而OpenJDK则是一个开源项目，它的实现相对简单，可能没有包含一些高级的优化和专有的代码。

响应性是指Java虚拟机（JVM）对用户输入的快速响应能力。

HotSpot是Java虚拟机（JVM）的一种实现
```



## 9. **Java和C++的区别**

相同点

都是面向对象语言，支持继承，封装和多态。

不同点

Java不提供指针来直接访问内存，程序内存更加安全。

Java类只支持单继承，C++类支持多继承，Java中接口支持多继承。

Java有自动内存管理机制，C++需要手动释放动态内存。

**Java字符串或字符数组不需要用额外字符'\0'来表示结束,而C++需要。（Java万物皆对象，数组对象有属性length）**

## 10. **字符型常量和字符串常量的区别?**

1.首先在形式上，字符型常量是用**单引号**引起来的一个字符，字符串常量是用**双引号**引起来的多个字符。

2.其次在含义上，字符型常量相当于一个**整型值**(ASCII值)，可以参加**表达式运算**。字符串常量代表一个**地址值**（表示该字符串在内存中存放的位置）

3.占内存大小 **字符型常量只占2个字节（char在Java中占两个字节），**字符串常量占若干个字节。

## 11. **Java八种基本数据所占空间大小**

**Java每种数据类型所占空间大小并不随着硬件的改变而改变**

**boolean true/false Boolean**

**byte 8bit Byte -128~127**

**char 16bit Character Unicode 0~Unicode 2****16****-1**

**short 16bit Short -2****15****~2****15****-1**

**int 32bit Integer -2****31****~2****31****-1**

**long 64bit Long -2****63****~2****63****-1**

**float 32bit Float IEEE754**

**double 64bit Double IEEE754**

## 12. **构造器Constructor是否可以被override(重写)？**

Constructor不能被重写，但是可以被重载，所以我们**一个类中有多个构造函数**的情况。

## 13. **重载和重写的区别**

重载发生在编译期，发生在同一个类中，方法名必须相同，参数不同，可以是参数类型不同，个数不同或者是顺序不同，方法的返回值和修饰符可以不同。实际上，重载就是同一个类中多个同名方法根据不同的传参来**执行不同的逻辑处理**。

重写发生在运行期，是子类对父类允许它访问的方法的逻辑处理过程进行的一次重新编写。方法名，参数列表，返回值类型都必须相同（返回值类型是**void和基本数据类型**，则重写时不可修改，但如果是**引用数据类型**，重写时可以==返回该引用类型的子类==），**访问权限修饰符范围大于等于父类**，但是抛出的**异常**是**父类方法异常的子类或者相等**。如果父类方法访问修饰符为**private/final/static则子类不能重写该方法**，但是被static修饰的方法能够被再次声明。最后就是，**构造器方法无法被重写**。实际上，重写就是子类对父类方法的重新改造，外部样式不能改变，内部逻辑可以改变。

## 14. **Java面向对象三大特性:封装 继承 多态**

1.封装：封装就是把一个对象的**属性私有化**，同时**向外界提供**可以访问该属性的**方法**。

2.继承：子类通过继承父类的属性和方法，可以方便的复用以前的代码。第一，子类拥有父类**所有的属性和方**法，包括私有属性和私有方法，但是无法访问。第二，子类可以**拥有自己属性和方法**，对父类进行扩展，第三，子类可以用**自己的方式实现**父类的方法。

3.多态：多态就是指，同一个方法，不同的对象调用效果可能不一样。程序中定义的引用变量发出的方法调用在编程时并不确定，而是在程序运行时才确定。**在Java中有两种形式可以实现多态实现**，一是==继承==，多个子类对父类的同一方法进行重写，二是==接口==，实现接口并覆盖接口中的同一方法。

## 15. **String,StringBuffer,StringBuilder的区别是什么？**

String对象是**不可变的**，可以理解为常量，线程安全。而StringBuiler和StringBuffer都继承了**AbstractStringBuiler，是可变的**。StringBuilder线程不安全，但是效率更高，StringBuffer对父类的方法加了==同步锁（synic）==，所以是线程安全的，但是效率比StringBuilder低。

## 16. **String为什么是不可变的？**

String类中**使用final关键字修饰字符数**组保存字符串。所以String对象是不可变的。同时String类被final修饰，不会被继承和扩展。（string是用final修饰，这里要说一下，并不是存引用值的a，b中的引用不可以改变，**而是创建的对象或常量对象其本身无法改变**，当改变其中一个时，会在**常量池**（缓冲池）或**堆**中创建一个**新的对象**并将对象的引用存入a,b（原对象本身并未改变）。为了解决这个问题stringbuffer和stringbuild出现了）

## 17. **String在内存中的实例化**

第一种方式: String str1 = "aaa"; 是**在常量池中获取对象**("aaa" 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象)

第二种方式: String str2 = new String("aaa") ; 一共**会创建两个字符串对象**，一个在常量池中（前提是常量池中还没有 "aaa" 字符串对象，一个在堆中。

如果不是用**双引号声明**的String对象,可以使用 String 提供的 intern 方法**。String.intern() 是一个 Native 方法**，它的作用是： 如果运行时常量池中已经有此 String 对象内容的字符串，则返回该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。

```
String s1 = new String("AAA");

String s2 = s1.intern();

String s3 = "AAA";

System.out.println(s2);//AAA

System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，

System.out.println(s2 == s3);//true， s2,s3指向常量池中的”AAA“
```



## 18. **"+"号拼接String的实现原理\***

首先将变量str存储局部变量表里，接着new StringBuilder()，并初始化，然后调用StringBuilder.append()方法拼接字符串，再通过StringBuilder.toString()调用new String()得到一个新的字符串变量，再将这个变量存储到局部变量表，最后return结束。所以代码过程其实为new StringBuilder().append(str).append("world").toString()。

而StringBuilder的toString()调用的是new String()

1、两个字符串直接拼接时，编译器对其进行了优化，此时String str = "hello" + "world"和String str = "helloworld"是一样的；

2、由上述的分析可以两个字符串的拼接的底层是通过StringBuilder的append方法先将字符串放在char[]数组中，再通过toString()调用new String()新建一个合适长度的char[]，再把旧的char[]复制到新的char[]上完成的，而一个小小的”+“拼接的过程经过了3次System.arraycopy，过程复杂，每次“+”都会new StringBuilder又要toString，若是在for循环中使用这种方式，可谓是呜呼哀哉，并且每次循环一次就会new StringBuilder()，若循环的次数非常多会new非常多的StringBuilder。

## 19. **自动装箱和拆箱**

装箱：将基本类型用它们对相应的引用类型包装起来。

拆箱：将包装类型转换为基本数据类型。

## 20. **int与Integer、new Integer()**

**（1）int与Integer、new Integer()进行==比较时，结果永远为true**

**（2）Integer与new Integer()进行==比较时，结果永远为false**

**（3）Integer与Integer进行==比较时，看范围；在大于等于-128小于等于127的范围内为true，在此范围外为false。**

## 21. **在一个静态方法中调用一个非静态成员为什么是非法的？**

因为静态方法可以通过类直接调用，而非静态成员变量随着类的实例化对象出现才出现，所以在静态方法中不能访问和调用非静态成员变量。

## 22. **为什么要定义空参构造器？**

因为Java程序在实例化子类，调用子类的构造器之前，如果没有显示用super调用父类的构造器，则会默认调用父类中的空参构造器。在父类中，如果没有定义构造器，则系统默认提供空参构造器，如果定义了其他构造器，则需要显示声明空参构造器，否则将在子类构造器调用时发生错误。

## 23. **import java和javax有什么区别？**

刚开始时，java开头的包是标准API包，javax作为扩展API包来使用，后来javax包也成为了标准API的一部分，二者实际上没有区别，只是名字不同。

### **private、default、protected、public的作用范围**

private:表示私有，只有自己的类能访问。----子类能继承，但是不能调用。

default：表示没有修饰符修饰（即默认），只有同一个包的类能访问。

protect：表示可以被同一个包的类以及其它包的子类访问。

public：表示可以被该项目中的所有包的所有类访问。